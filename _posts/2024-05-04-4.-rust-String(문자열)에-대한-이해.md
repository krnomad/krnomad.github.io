---
layout: post
date: 2024-05-04
title: "4. rust String(문자열)에 대한 이해"
tags: [rust, ]
categories: [rust, ]
pin: true
---


Rust에서는 문자열에 대한 다양한 개념이 존재하며, 이를 이해하는 것은 중요합니다. 이 글에서는 Rust 표준 라이브러리에서 제공되는 문자열의 두 가지 중요한 타입에 대해 살펴보겠습니다.

1. **불변한 Borrowed String Slice**: 문자열 슬라이스는 대부분 빌려오는(borrowed) 형태로 사용됩니다. 리터럴 문자열은 항상 빌려오는 문자열 슬라이스입니다. 이는 데이터를 수정할 수 없다는 것이 가장 큰 차이점입니다.
2. **가변한 String**: 대문자로 시작하는 **`String`** 타입은 데이터를 수정할 수 있는 가변적인 문자열입니다.

문자열 슬라이스와 문자열은 서로 다른 타입이지만 많은 공통점을 가지고 있습니다. 예를 들어 둘 다 UTF-8으로 인코딩되어 있으며, **문자 위치로 인덱싱할 수 없습니다**. 이는 Unicode의 다양한 문자들을 고려하여 설계되었습니다.


Unicode 문자열은 바이트 단위로 인덱싱하는 것이 아니라 그래핀(graphemes)에 대한 접근이 필요합니다. Rust는 이에 대한 고려를 하여 라이브러리 컬렉션에 대한 인덱싱 작업을 상수 시간 내에 수행할 수 없습니다.


따라서 문자열을 다룰 때 다음과 같은 방법들을 고려할 수 있습니다.

- **`bytes()`**: UTF-8 바이트의 벡터에 접근하여 인덱싱할 수 있습니다.
- **`chars()`**: Unicode 스칼라에 대한 반복자를 반환하여 그래핀(graphemes)를 순회할 수 있습니다.
- **`unicode-segmentation`** 패키지를 사용하여 그래핀(graphemes)임을 처리할 수 있는 반복자를 반환할 수 있습니다.

{% raw %}
```rust
fn main() {
    let s = "안녕하세요";

    // 바이트 단위로 접근
    println!("바이트 단위로 접근");
    for b in s.bytes() {
        println!("{}", b);
    }

    println!("유니코드 스칼라에 대한 반복자");
    for c in s.chars() {
        println!("{}", c);
    }

    // println!("{}", s);
    println!("s.chars().nth(3) 문자 출력");
    println!("{}", s.chars().nth(3).unwrap());
}

```
{% endraw %}


output


{% raw %}
```text
바이트 단위로 접근
236
149
136
235
133
149
237
149
152
236
132
184
236
154
148
유니코드 스칼라에 대한 반복자
안
녕
하
세
요
s.chars().nth(3) 문자 출력
세

```
{% endraw %}


이러한 접근 방식들은 각각의 장단점을 가지고 있으며, 상황에 따라 적절한 방법을 선택해야 합니다. 특히 수동으로 반복자를 사용하는 경우에는 **`nth()`** 메서드를 사용하여 인덱싱을 대체할 수 있습니다.

